"""
Commandes de diagnostic r√©serv√©es aux propri√©taires du bot
"""
import discord
from discord.ext import commands
from core.bot_owner_manager import is_bot_owner
import os
import psutil
from datetime import datetime, timedelta


class DiagnosticOwnerCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.group(name="diag", help="Commandes de diagnostic pour propri√©taires", invoke_without_command=True)
    async def diag_group(self, ctx):
        """Commandes de diagnostic r√©serv√©es aux propri√©taires"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Ces commandes sont r√©serv√©es aux propri√©taires du bot.")
            return

        embed = discord.Embed(
            title="üîß Commandes de Diagnostic - Propri√©taires",
            description="Outils de diagnostic et de monitoring du bot",
            color=0x3498db
        )

        embed.add_field(
            name="üìä Informations Syst√®me",
            value="`!diag system` - Informations syst√®me\n"
                  "`!diag bot` - Statistiques du bot\n"
                  "`!diag servers` - Liste des serveurs\n"
                  "`!diag uptime` - Temps de fonctionnement\n"
                  "`!serveur [page]` - Liste d√©taill√©e des serveurs\n"
                  "`!link <server_id>` - Lien d'invitation par MP",
            inline=False
        )

        embed.add_field(
            name="üîß Maintenance",
            value="`!diag sync` - Synchroniser les commandes slash\n"
                  "`!diag reload <module>` - Recharger un module\n"
                  "`!diag cache` - Informations cache",
            inline=False
        )

        await ctx.send(embed=embed)

    @diag_group.command(name='system', aliases=['sys'])
    async def diag_system(self, ctx):
        """Affiche les informations syst√®me"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        # Informations syst√®me
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')

        embed = discord.Embed(
            title="üñ•Ô∏è Informations Syst√®me",
            color=0x3498db
        )

        embed.add_field(
            name="üíª CPU",
            value=f"{cpu_percent}% utilis√©",
            inline=True
        )

        embed.add_field(
            name="üß† RAM",
            value=f"{memory.percent}% utilis√©\n{memory.used // (1024**3):.1f}GB / {memory.total // (1024**3):.1f}GB",
            inline=True
        )

        embed.add_field(
            name="üíæ Disque",
            value=f"{disk.percent}% utilis√©\n{disk.used // (1024**3):.1f}GB / {disk.total // (1024**3):.1f}GB",
            inline=True
        )

        embed.add_field(
            name="üêç Python",
            value=f"Version {os.sys.version.split()[0]}",
            inline=True
        )

        embed.add_field(
            name="üì¶ Discord.py",
            value=f"Version {discord.__version__}",
            inline=True
        )

        embed.add_field(
            name="üïí Heure serveur",
            value=datetime.now().strftime("%H:%M:%S"),
            inline=True
        )

        await ctx.send(embed=embed)

    @diag_group.command(name='bot')
    async def diag_bot(self, ctx):
        """Affiche les statistiques du bot"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        # Calcul de l'uptime
        if hasattr(self.bot, 'start_time'):
            uptime = datetime.now() - self.bot.start_time
            # Supprimer les microsecondes
            uptime_str = str(uptime).split('.')[0]
        else:
            uptime_str = "Inconnu"

        embed = discord.Embed(
            title="ü§ñ Statistiques du Bot",
            color=0x2ecc71
        )

        embed.add_field(
            name="üìä Serveurs",
            value=f"{len(self.bot.guilds)} serveurs connect√©s",
            inline=True
        )

        embed.add_field(
            name="üë• Utilisateurs",
            value=f"{len(self.bot.users)} utilisateurs visibles",
            inline=True
        )

        embed.add_field(
            name="‚è∞ Uptime",
            value=uptime_str,
            inline=True
        )

        embed.add_field(
            name="üèì Latence",
            value=f"{round(self.bot.latency * 1000)}ms",
            inline=True
        )

        embed.add_field(
            name="üì° Statut",
            value="üü¢ En ligne" if self.bot.is_ready() else "üî¥ Hors ligne",
            inline=True
        )

        # Informations sur les modules charg√©s
        cogs_count = len(self.bot.cogs)
        embed.add_field(
            name="üì¶ Modules",
            value=f"{cogs_count} modules charg√©s",
            inline=True
        )

        await ctx.send(embed=embed)

    @diag_group.command(name='servers', aliases=['guilds'])
    async def diag_servers(self, ctx):
        """Liste les serveurs o√π le bot est connect√©"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        embed = discord.Embed(
            title=f"üè† Serveurs Connect√©s ({len(self.bot.guilds)})",
            color=0x3498db
        )

        for guild in self.bot.guilds[:10]:  # Limiter √† 10 serveurs
            embed.add_field(
                name=f"üìç {guild.name}",
                value=f"ID: `{guild.id}`\n"
                f"Membres: {guild.member_count}\n"
                f"Propri√©taire: {guild.owner.mention if guild.owner else 'Inconnu'}",
                inline=True
            )

        if len(self.bot.guilds) > 10:
            embed.add_field(
                name="üìã Note",
                value=f"... et {len(self.bot.guilds) - 10} autres serveurs",
                inline=False
            )

        await ctx.send(embed=embed)

    @diag_group.command(name='sync')
    async def diag_sync(self, ctx):
        """Synchronise les commandes slash"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        try:
            synced = await self.bot.tree.sync()
            embed = discord.Embed(
                title="‚úÖ Synchronisation R√©ussie",
                description=f"{len(synced)} commande(s) slash synchronis√©e(s)",
                color=0x2ecc71
            )
            await ctx.send(embed=embed)
        except Exception as e:
            embed = discord.Embed(
                title="‚ùå Erreur de Synchronisation",
                description=f"Erreur: {str(e)}",
                color=0xe74c3c
            )
            await ctx.send(embed=embed)

    @diag_group.command(name='uptime')
    async def diag_uptime(self, ctx):
        """Affiche le temps de fonctionnement d√©taill√©"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        if not hasattr(self.bot, 'start_time'):
            await ctx.send("‚ùå L'heure de d√©marrage n'est pas disponible.")
            return

        now = datetime.now()
        uptime = now - self.bot.start_time

        days = uptime.days
        hours, remainder = divmod(uptime.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)

        embed = discord.Embed(
            title="‚è∞ Temps de Fonctionnement",
            color=0x3498db
        )

        embed.add_field(
            name="üöÄ D√©marr√© le",
            value=self.bot.start_time.strftime("%d/%m/%Y √† %H:%M:%S"),
            inline=False
        )

        embed.add_field(
            name="‚è±Ô∏è Dur√©e totale",
            value=f"{days} jour(s), {hours}h {minutes}m {seconds}s",
            inline=False
        )

        embed.add_field(
            name="üìÖ Maintenant",
            value=now.strftime("%d/%m/%Y √† %H:%M:%S"),
            inline=False
        )

        await ctx.send(embed=embed)

    @commands.command(name="serveur", aliases=["serveurs", "servers"], help="Liste d√©taill√©e des serveurs du bot (propri√©taires uniquement)")
    async def serveur_command(self, ctx, page: int = 1):
        """Affiche la liste d√©taill√©e des serveurs o√π le bot est pr√©sent"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        guilds = self.bot.guilds
        if not guilds:
            await ctx.send("‚ùå Le bot n'est pr√©sent sur aucun serveur.")
            return

        # Pagination
        per_page = 5
        total_pages = (len(guilds) + per_page - 1) // per_page

        if page < 1 or page > total_pages:
            await ctx.send(f"‚ùå Page invalide. Utilisez une page entre 1 et {total_pages}.")
            return

        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        page_guilds = guilds[start_idx:end_idx]

        embed = discord.Embed(
            title=f"üåê Serveurs Discord - Page {page}/{total_pages}",
            description=f"Le bot est pr√©sent sur **{len(guilds)}** serveur(s)",
            color=0x3498db
        )

        for guild in page_guilds:
            try:
                # Informations de base
                member_count = guild.member_count or len(guild.members)
                online_count = sum(
                    1 for member in guild.members if member.status != discord.Status.offline)

                # Propri√©taire du serveur
                owner_info = "Inconnu"
                if guild.owner:
                    owner_info = f"{guild.owner.display_name} ({guild.owner.name}#{guild.owner.discriminator})"

                # Date de cr√©ation
                created_at = guild.created_at.strftime("%d/%m/%Y")

                # Date d'arriv√©e du bot
                bot_member = guild.get_member(self.bot.user.id)
                joined_at = "Inconnue"
                if bot_member and bot_member.joined_at:
                    joined_at = bot_member.joined_at.strftime("%d/%m/%Y")

                # Informations sur les canaux
                text_channels = len(guild.text_channels)
                voice_channels = len(guild.voice_channels)

                # R√¥les
                role_count = len(guild.roles) - 1  # -1 pour exclure @everyone

                field_value = (
                    f"**üë• Membres:** {member_count} ({online_count} en ligne)\n"
                    f"**üëë Propri√©taire:** {owner_info}\n"
                    f"**üìÖ Cr√©√© le:** {created_at}\n"
                    f"**ü§ñ Bot arriv√© le:** {joined_at}\n"
                    f"**üìù Canaux texte:** {text_channels}\n"
                    f"**üîä Canaux vocaux:** {voice_channels}\n"
                    f"**üé≠ R√¥les:** {role_count}\n"
                    f"**üÜî ID:** `{guild.id}`"
                )

                # √âmoji pour indiquer le niveau de permissions
                permissions = guild.get_member(
                    self.bot.user.id).guild_permissions
                admin_status = "üõ°Ô∏è" if permissions.administrator else "‚öôÔ∏è"

                embed.add_field(
                    name=f"{admin_status} {guild.name}",
                    value=field_value,
                    inline=False
                )

            except Exception as e:
                embed.add_field(
                    name=f"‚ùå {guild.name}",
                    value=f"Erreur lors de la r√©cup√©ration des informations: {str(e)[:100]}...",
                    inline=False
                )

        # Statistiques globales
        total_members = sum(guild.member_count or 0 for guild in guilds)
        embed.set_footer(
            text=f"üìä Total: {len(guilds)} serveurs ‚Ä¢ {total_members} membres ‚Ä¢ Page {page}/{total_pages}"
        )

        await ctx.send(embed=embed)

    @commands.command(name="link", help="Envoie un lien d'invitation pour un serveur sp√©cifique")
    async def link_server(self, ctx, server_id: int = None):
        """Envoie un lien d'invitation pour un serveur sp√©cifique par MP"""
        if not is_bot_owner(ctx.author.id):
            await ctx.send("‚ùå Cette commande est r√©serv√©e aux propri√©taires du bot.")
            return

        if server_id is None:
            await ctx.send("‚ùå Veuillez sp√©cifier l'ID du serveur.\nUtilisation: `!link <server_id>`")
            return

        # Rechercher le serveur
        guild = self.bot.get_guild(server_id)
        if not guild:
            await ctx.send(f"‚ùå Serveur avec l'ID `{server_id}` introuvable ou le bot n'y est pas pr√©sent.")
            return

        try:
            # Chercher un canal o√π le bot peut cr√©er une invitation
            invite_channel = None

            # Priorit√© 1: Canal g√©n√©ral/syst√®me
            if guild.system_channel and guild.system_channel.permissions_for(guild.me).create_instant_invite:
                invite_channel = guild.system_channel
            # Priorit√© 2: Premier canal texte o√π le bot peut cr√©er des invitations
            else:
                for channel in guild.text_channels:
                    if channel.permissions_for(guild.me).create_instant_invite:
                        invite_channel = channel
                        break

            if not invite_channel:
                await ctx.send(f"‚ùå Impossible de cr√©er une invitation pour `{guild.name}`. Le bot n'a pas les permissions n√©cessaires.")
                return

            # Cr√©er l'invitation
            invite = await invite_channel.create_invite(
                max_age=86400,  # 24 heures
                max_uses=1,     # Une seule utilisation
                unique=True,
                reason=f"Invitation demand√©e par le propri√©taire {ctx.author}"
            )

            # Cr√©er l'embed d'informations
            embed = discord.Embed(
                title="üîó Lien d'invitation g√©n√©r√©",
                description=f"Invitation pour le serveur **{guild.name}**",
                color=0x00ff00,
                timestamp=datetime.utcnow()
            )

            embed.add_field(
                name="üìã Informations du serveur",
                value=f"**Nom:** {guild.name}\n"
                f"**ID:** {guild.id}\n"
                f"**Propri√©taire:** {guild.owner.mention if guild.owner else 'Inconnu'}\n"
                f"**Membres:** {guild.member_count}\n"
                f"**Cr√©√© le:** {guild.created_at.strftime('%d/%m/%Y √† %H:%M')}",
                inline=False
            )

            embed.add_field(
                name="üîó Lien d'invitation",
                value=f"[Cliquez ici pour rejoindre]({invite.url})\n"
                f"`{invite.url}`",
                inline=False
            )

            embed.add_field(
                name="‚öôÔ∏è Param√®tres de l'invitation",
                value=f"**Expire dans:** 24 heures\n"
                f"**Utilisations max:** 1\n"
                f"**Canal:** {invite_channel.mention}",
                inline=False
            )

            if guild.icon:
                embed.set_thumbnail(url=guild.icon.url)

            embed.set_footer(
                text=f"Demand√© par {ctx.author}",
                icon_url=ctx.author.avatar.url if ctx.author.avatar else None
            )

            # Envoyer en MP
            try:
                await ctx.author.send(embed=embed)
                await ctx.send(f"‚úÖ Lien d'invitation pour `{guild.name}` envoy√© en message priv√©.")
            except discord.Forbidden:
                # Si impossible d'envoyer en MP, envoyer dans le canal (avec avertissement)
                await ctx.send("‚ö†Ô∏è Impossible d'envoyer en MP. Voici le lien (supprimez ce message rapidement):")
                await ctx.send(embed=embed)

        except discord.HTTPException as e:
            await ctx.send(f"‚ùå Erreur lors de la cr√©ation de l'invitation: {str(e)}")
        except Exception as e:
            await ctx.send(f"‚ùå Une erreur inattendue s'est produite: {str(e)}")


async def setup(bot):
    await bot.add_cog(DiagnosticOwnerCommands(bot))
